# Generated by using Rcpp::compileAttributes() -> do not edit by hand
# Generator token: 10BE3573-1514-4C36-9D1C-5A225CD40393

#' Closure divide each column by column sum
#' @param X matrix (D x N)
#' @return matrix of same dimension as X
#' @export
clo <- function(X) {
    .Call('_RcppCoDA_clo', PACKAGE = 'RcppCoDA', X)
}

#' Center - subtract each column by column mean
#' @param X matrix (D x N)
#' @return matrix of same dimension as X
#' @export
center <- function(X) {
    .Call('_RcppCoDA_center', PACKAGE = 'RcppCoDA', X)
}

#' Log-Ratio Transformation
#'
#' \code{glr} is generic log-ratio transform, code used by other
#' transforms, can be called directly. *Contrast functions produce contrast 
#' matricies (e.g., "V") that define the various transforms. 
#'
#' @param X vector or matrix (rows are parts/coordinates, columns are samples) of data
#' @param V transformation matrix (defines transform; P x D where D is number of parts)
#'   if NULL then uses ilr default basis (see details)
#' @param d for ALR, which component (integer position) to take as reference
#' (default is nrow(x)) for alrInv corresponds to column position in untransformed
#' matrix.
#' @param inv for ALR and CLR, transformation matrix is different forward and inverse
#' @param D the number of parts (e.g., number of columns in untransformed data)
#' @return matrix (converts vectors to column matricies)
#' @details The default ILR base formed by Gram-Schmidt orthogonalization of an ALR_D basis.
#' @name base_lr_transforms
#' @examples
#' #ALR Transform
#' x <- matrix(runif(30), 10, 3)
#' x <- clo(x)
#' x.alr <- alr(x, 2)
#' x <- alrInv(x.alr, 2)
#'
#' # ILR
#' x.ilr <- ilr(x)
#' x <- ilrInv(x.ilr)
#'
#' # CLR
#' x.clr <- clr(x)
#' x <- clrInv(x.clr)
#'
#' # CUSTOM - Be careful if your custom matrix is not
#' # orthogonal the inverse transform may not be given by just the transpose!
#' # For example, this is the case for the ALR
#' V <- matrix(c(1, 1, -1), 1, 3)
#' x.custom <- glr(x, V)
#' @export
alrContrast <- function(D, d, inv) {
    .Call('_RcppCoDA_alrContrast', PACKAGE = 'RcppCoDA', D, d, inv)
}

#' @rdname base_lr_transforms
#' @export
clrContrast <- function(D, inv) {
    .Call('_RcppCoDA_clrContrast', PACKAGE = 'RcppCoDA', D, inv)
}

#' @rdname base_lr_transforms
#' @export
ilrContrast <- function(D) {
    .Call('_RcppCoDA_ilrContrast', PACKAGE = 'RcppCoDA', D)
}

#' @rdname base_lr_transforms
#' @export
glr <- function(X, V) {
    .Call('_RcppCoDA_glr', PACKAGE = 'RcppCoDA', X, V)
}

#' @rdname base_lr_transforms
#' @export
glrInv <- function(X, V) {
    .Call('_RcppCoDA_glrInv', PACKAGE = 'RcppCoDA', X, V)
}

#' @rdname base_lr_transforms
#' @export
alr <- function(X, d) {
    .Call('_RcppCoDA_alr', PACKAGE = 'RcppCoDA', X, d)
}

#' @rdname base_lr_transforms
#' @export
alrInv <- function(X, d) {
    .Call('_RcppCoDA_alrInv', PACKAGE = 'RcppCoDA', X, d)
}

#' @rdname base_lr_transforms
#' @export
clr <- function(X) {
    .Call('_RcppCoDA_clr', PACKAGE = 'RcppCoDA', X)
}

#' @rdname base_lr_transforms
#' @export
clrInv <- function(X) {
    .Call('_RcppCoDA_clrInv', PACKAGE = 'RcppCoDA', X)
}

#' @rdname base_lr_transforms
#' @export
ilr <- function(X, V = NULL) {
    .Call('_RcppCoDA_ilr', PACKAGE = 'RcppCoDA', X, V)
}

#' @rdname base_lr_transforms
#' @export
ilrInv <- function(X, V = NULL) {
    .Call('_RcppCoDA_ilrInv', PACKAGE = 'RcppCoDA', X, V)
}

