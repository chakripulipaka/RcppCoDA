# Generated by using Rcpp::compileAttributes() -> do not edit by hand
# Generator token: 10BE3573-1514-4C36-9D1C-5A225CD40393

#' Closure operation - divide elements by sum of elements in b dimension
#' @param X vector, matrix, or array of data 
#'   (b is the dimension which is relevant to be closed)
#' @param b index of dimension to operate on 
#'   (e.g., index of dimension of parts or coords in X;
#'   default is 1 meaning that compositions/log-ratios are rows)
#' @export
clo <- function(X) {
    .Call(`_RcppCoDA_clo`, X)
}

#' Center operation - subtract from each element the mean of elements in b dimension
#' @param X vector, matrix, or array of data 
#'   (b is the dimension which is relevant to be centered)
#' @param b index of dimension to operate on 
#'   (e.g., index of dimension of parts or coords in X;
#'   default is 1 meaning that compositions/log-ratios are rows)
#' @export
center <- function(X) {
    .Call(`_RcppCoDA_center`, X)
}

#' Log-Ratio Transformation
#'
#' \code{glr} is generic log-ratio transform, code used by other
#' transforms, can be called directly. *Contrast functions produce contrast 
#' matricies (e.g., "V") that define the various transforms. 
#'
#' @param X vector, matrix, or array of data (b is the dimension which is compositionally relevant)
#' @param V transformation matrix (defines transform; P x D where D is number of parts)
#'   if NULL then uses ilr default basis (see details)
#' @param d for ALR, which component (integer position) to take as reference
#' (default is nrow(x) for alr or nrow(x)+1 for alrInv) for alrInv corresponds 
#' to column position in untransformed matrix. ilrContrast can accept a D-1 x D sign matrix to produce a 
#' Sequential Binary Partition basis. 
#' @param b index of dimension to operate on (e.g., index of dimension of parts or coords in X;
#' default is 1 meaning that compositions/log-ratios are rows)
#' @param inv for ALR and CLR, transformation matrix is different forward and inverse
#' @param D the number of parts (e.g., number of columns in untransformed data)
#' @return matrix (converts vectors to column matricies)
#' @details The default ILR base formed by Gram-Schmidt orthogonalization of an ALR_D basis.
#' @name base_lr_transforms
#' @examples
#' #ALR Transform
#' x <- matrix(runif(30), 10, 3)
#' x <- clo(x)
#' x.alr <- alr(x, 2)
#' x <- alrInv(x.alr, 2)
#'
#' # ILR
#' x.ilr <- ilr(x)
#' x <- ilrInv(x.ilr)
#'
#' # CLR
#' x.clr <- clr(x)
#' x <- clrInv(x.clr)
#' @export
glr <- function(X, V) {
    .Call(`_RcppCoDA_glr`, X, V)
}

#' @rdname base_lr_transforms
#' @export
glrInv <- function(X, V) {
    .Call(`_RcppCoDA_glrInv`, X, V)
}

#' @rdname base_lr_transforms
#' @export
alrContrast <- function(d, D, inv) {
    .Call(`_RcppCoDA_alrContrast`, d, D, inv)
}

#' @rdname base_lr_transforms
#' @export
clrContrast <- function(D, inv) {
    .Call(`_RcppCoDA_clrContrast`, D, inv)
}

ilrContrastDefault_internal <- function(D) {
    .Call(`_RcppCoDA_ilrContrastDefault_internal`, D)
}

ilrContrastSign_internal <- function(S) {
    .Call(`_RcppCoDA_ilrContrastSign_internal`, S)
}

#' @rdname base_lr_transforms
#' @export
alr <- function(X, d = NULL) {
    .Call(`_RcppCoDA_alr`, X, d)
}

#' @rdname base_lr_transforms
#' @export
alrInv <- function(X, d = NULL) {
    .Call(`_RcppCoDA_alrInv`, X, d)
}

#' @rdname base_lr_transforms
#' @export
clr <- function(X) {
    .Call(`_RcppCoDA_clr`, X)
}

#' @rdname base_lr_transforms
#' @export
clrInv <- function(X) {
    .Call(`_RcppCoDA_clrInv`, X)
}

#' @rdname base_lr_transforms
#' @export
ilr <- function(X, V = NULL) {
    .Call(`_RcppCoDA_ilr`, X, V)
}

#' @rdname base_lr_transforms
#' @export
ilrInv <- function(X, V = NULL) {
    .Call(`_RcppCoDA_ilrInv`, X, V)
}

