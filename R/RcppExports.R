# Generated by using Rcpp::compileAttributes() -> do not edit by hand
# Generator token: 10BE3573-1514-4C36-9D1C-5A225CD40393

#' Closure divide each column by column sum
#' @param X matrix (D x N)
#' @return matrix of same dimension as X
#' @export
miniclo <- function(X) {
    .Call('_RcppCoDA_miniclo', PACKAGE = 'RcppCoDA', X)
}

#' Create ALR contrast matrix
#' @param D total number of parts
#' @param d reference part for ALR
#' @param inv (is this being used for the alr or alrInv?)
#' @return D-1 x D matrix
#' @export
alrContrast <- function(D, d, inv) {
    .Call('_RcppCoDA_alrContrast', PACKAGE = 'RcppCoDA', D, d, inv)
}

#' Create DEFAULT ILR contrast matrix
#' @param D total number of parts
#' @return D-1 x D matrix (a basis)
#' @export
ilrContrast <- function(D) {
    .Call('_RcppCoDA_ilrContrast', PACKAGE = 'RcppCoDA', D)
}

#' Create CLR contrast matrix
#' @param D total number of parts
#' @return D-1 x D matrix (a basis)
#' @export
clrContrast <- function(D) {
    .Call('_RcppCoDA_clrContrast', PACKAGE = 'RcppCoDA', D)
}

#' Generalized LR Transform
#' @param X data (parts x samples aka D x N)
#' @param V contrast matrix (P x D)
glr <- function(X, V) {
    .Call('_RcppCoDA_glr', PACKAGE = 'RcppCoDA', X, V)
}

#' Generalized LR Inverse Transform
#' @param X data (coords x samples aka P x N)
#' @param V contrast matrix (P x D)
glrInv <- function(X, V) {
    .Call('_RcppCoDA_glrInv', PACKAGE = 'RcppCoDA', X, V)
}

#' Additive LR Transform
#' @param X data (parts x samples aka P x N)
#' @param d index of part to take as reference for ALR 
#'   (e.g., number of the part that goes in the denominator)
alr <- function(X, d) {
    .Call('_RcppCoDA_alr', PACKAGE = 'RcppCoDA', X, d)
}

#' Inverse Additive LR Transform
#' @param X data (coords x samples aka P x N)
#' @param d index of part to take as reference for ALR 
#'   (e.g., number of the part that goes in the denominator)
alrInv <- function(X, d) {
    .Call('_RcppCoDA_alrInv', PACKAGE = 'RcppCoDA', X, d)
}

